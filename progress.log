4_18_2017 -->
MB suggests that we randomize atomic operations to obfuscate pattern generated by consistant memory bus locking
  - idea is that same operation over and over would be easy to detect as malicious (if Bracket can monitor this)

VirtualBox with (2) Ubuntu 14.04 instances set up successfully
  - 1GB of RAM
  - 30 GB of disk
<--

4_20_2017 -->
"find index[0,1]/type -exec cat {} \;"
MB
Cache information: path -- /sys/devices/system/cpu/<cpu_index>/cache/
  1. index0 is data L1 cache
  2. index1 is instruction L1 cache
  3. index2 is L2 cache
  4. index3 is L3 cache

      LLC info (L3) -->
        size: 6144KB, ways: 12, sets: 8192, line_size: 64
      <--
  
JN
CPU information: path -- /proc/cpuinfo
  1. MHz = 1600.0
  2. Cache alignment = 64
  3. important flags for latency measuring: rdtscp constant_tsc nonstop_tsc
     a. this means that we are able to use rdtscp reliably for clock performance
 
Now that we have the cache and clock information, implementation of the probing code can begin. 
  - meet with Prof Loew to discuss memory locking and potential avenues

      Pseudo-code for sender-->
      // allocate memory multiples of 64 bits
      char_ptr = allocate_memory((N+1)*8)
      //move half word up
      unaligned_addr = char_ptr + 2

      loop forever:
        loop i from (1..N):
          atomic_op(unaligned_addr + i, some_value)
        end loop
      end loop
      <--

      Pseudo-code for probe -->
      size = LLC_size * (LLC_ways + 1)
      stride = LLC_sets * cacheline_sz
      buffer = alloc_ptr_chasing_buff(size, stride)

      loop sample from (1..10): //number of samples
        start_rdtsc = rdtsc()
        loop probes from (1..10000):
          probe(buffer); //always hits memory
        end loop
        time_taken[sample] = (rdtsc() - start_rdtsc)
      end loop
      <--

<--

4_25_17 -->
rdtscp code implemented (MB)

implementation of ptr-chasing probe started (JN)
<--

4_27_17 -->
probe.c debugged and ready for action (JN)
	1. able to run through iterations, roughly 2,000,000 cycle runtime

"perf" utiltity will come in handy evaluating the performance degredation

generic code for portability one its way (MB)

TODO: 
1. Write memory locking code!
2. Begin write up; easier now than later
3. Get benchmarks for probe running alone
<--

5_1_17 -->
Updated gcc compiler to 4.9 (JN)

Memory locking complete, atomic add on unaligned pointer locks memory bus (JN)
       1. Used "stdatomic.h" lib to create an atomic_char pointer
       2. Offset the pointer by half word (2 bytes)
       3. Infinite loop adding one to each byte in the atomic buffer that points to atomic_ints
       	  a. Reference to unaligned pointer that spans a cache line goes straight to memory

Another potential for memory bus locking is mem-mapped I/O (JN)
	1. Not sure how plausible it would be on public cloud
	
Multithreaded lock implemented, increase contension at memory bus (JN)

<--

Resources:

http://btorpey.github.io/blog/2014/02/18/clock-sources-in-linux/ --> Measuring Latency in Linux
https://github.com/btorpey/clocks/blob/master/ClockBench.cpp --> example code for assembly RDTSCP
https://github.com/afborchert/pointer-chasing --> utility for measuring access times

Dependencies:

VirtualBox
Ubuntu 14.4
gcc 4.9 to include "stdatomic.h" lib
